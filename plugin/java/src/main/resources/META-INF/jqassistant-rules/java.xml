<jqa:jqassistant-rules xmlns:jqa="http://www.buschmais.com/jqassistant/core/rule/schema/v1.4">

    <concept id="java:InnerType">
        <description>Sets a label "Inner" on inner types.</description>
        <cypher><![CDATA[
            MATCH
              (:Type)-[:DECLARES]->(innerType:Type)
            SET
              innerType:Inner
            RETURN
              innerType AS InnerType
        ]]></cypher>
    </concept>

    <concept id="java:AnonymousInnerType">
        <requiresConcept refId="java:InnerType"/>
        <description>Sets a label "Anonymous" on anonymous inner types, i.e. types without a name.</description>
        <cypher><![CDATA[
            MATCH
              (innerType:Inner:Type)
            WHERE
              innerType.name =~ ".*\\$[0-9]*"
            SET
              innerType:Anonymous
            RETURN
              innerType AS AnonymousInnerType
        ]]></cypher>
    </concept>

    <concept id="java:TypeAssignableFrom">
        <description>Creates a relationship ASSIGNABLE_FROM between two "Type" labeled nodes if one type is assignable from the other (i.e. a super class or
            interface).
        </description>
        <cypher><![CDATA[
            MATCH
              (type:Type)
            MERGE
              (type)-[:ASSIGNABLE_FROM]->(type)
            WITH
              type
            MATCH
              (type)-[:IMPLEMENTS|EXTENDS*]->(superType:Type)
            MERGE
              (superType)-[:ASSIGNABLE_FROM]->(type)
            RETURN type AS AssignableType, superType AS AssignableFrom
        ]]></cypher>
    </concept>

    <concept id="java:MethodOverrides">
        <description>Creates a relationship OVERRIDES between two "Method" labeled nodes if one method overrides another one from a super type (i.e. the methods have the same signature).
        </description>
        <cypher><![CDATA[
            MATCH
              (type:Type)-[:DECLARES]->(method:Method),
              (superType:Type)-[:DECLARES]->(otherMethod:Method),
              (type)-[:EXTENDS|IMPLEMENTS*]->(superType)
            WHERE
              method.name = otherMethod.name
              AND method.signature = otherMethod.signature
              AND method.visibility <> 'private'
            MERGE
              (method)-[:OVERRIDES]->(otherMethod)
            RETURN method AS OverriddenMethod, type AS DeclaringType, superType AS SuperType
        ]]></cypher>
    </concept>

    <concept id="java:VirtualDependsOn">
        <description>Propagates DEPENDS_ON relationships as VIRTUAL_DEPENDS_ON to types that extend or implement the referenced type.</description>
        <cypher><![CDATA[
            MATCH
              (type:Type)-[:EXTENDS|IMPLEMENTS*]->(superType:Type),
              (dependent:Type)-[:DEPENDS_ON]->(superType)
            WHERE NOT
              (dependent)-[:EXTENDS|IMPLEMENTS*]->(superType) // exclude types sharing the same super classes/interfaces
            MERGE
              (dependent)-[virtualDependsOn:VIRTUAL_DEPENDS_ON]->(type)
            RETURN
              count(virtualDependsOn) AS VirtualDependsOn
        ]]></cypher>
        <verify>
           <aggregation/>
        </verify>
    </concept>

    <concept id="java:VirtualInvokes">
        <requiresConcept refId="java:MethodOverrides"/>
        <description>Propagates INVOKES relationships as VIRTUAL_INVOKES to methods which implement or override the invoked method.</description>
        <cypher><![CDATA[
            MATCH
              (method:Method)-[invokes:INVOKES]->(invokedMethod:Method),
              (overridingMethod:Method)-[:OVERRIDES]->(invokedMethod)
            MERGE
              (method)-[virtualInvokes:VIRTUAL_INVOKES{lineNumber:invokes.lineNumber}]->(overridingMethod)
            RETURN
              count(virtualInvokes) AS VirtualInvokes
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="java:InvokesOverriddenMethod">
        <requiresConcept refId="java:MethodOverrides"/>
        <requiresConcept refId="java:TypeAssignableFrom"/>
        <description>Propagates INVOKES relationships to methods which implement or override the invoked method.</description>
        <deprecated>To avoid ambiguities between INVOKES relations this concept has been replaced by "java:VirtualInvokes".</deprecated>
        <cypher><![CDATA[
            MATCH
              (method:Method)-[invocation:INVOKES]->(invokedMethod:Method),
              (overridingMethod:Method)-[:OVERRIDES]->(invokedMethod)
            MERGE
              (method)-[r:INVOKES{lineNumber:invocation.lineNumber}]->(overridingMethod)
            RETURN count(r) AS OverridingInvocations
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="java:MethodOverloads">
        <description>Creates a relationship OVERLOADS between two "Method" labeled nodes if one method overloads another one from the same type (i.e. the
            methods have the same name but not the same signature).
        </description>
        <cypher><![CDATA[
            MATCH
              (type:Type)-[:DECLARES]->(method:Method),
              (type)-[:DECLARES]->(otherMethod:Method)
            WHERE
              method <> otherMethod
              AND method.name = otherMethod.name
              AND method.signature <> otherMethod.signature
            MERGE
              (method)-[:OVERLOADS]->(otherMethod)
            RETURN method AS OverloadedMethod, type AS DeclaringType
        ]]></cypher>
    </concept>

    <concept id="java:Deprecated">
        <description>Labels all nodes representing deprecated elements (types, fields, methods, packages or parameters) with "Deprecated".</description>
        <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(dt:Type)
            WHERE
              dt.fqn='java.lang.Deprecated'
            SET
              e:Deprecated
            RETURN
              e AS DeprecatedElement
        ]]></cypher>
    </concept>

    <concept id="java:Exception">
        <description>Labels types deriving from java.lang.Exception as "Exception".</description>
        <cypher><![CDATA[
            MATCH
              (exception)-[:EXTENDS*]->(t:Type)
            WHERE
              t.fqn = 'java.lang.Exception'
            SET
              exception:Exception
            RETURN
              exception AS Exception
        ]]></cypher>
    </concept>

    <concept id="java:RuntimeException">
        <description>Labels types deriving from java.lang.RuntimeException as "RuntimeException".</description>
        <cypher><![CDATA[
            MATCH
              (runtimeException)-[:EXTENDS*]->(t:Type)
            WHERE
              t.fqn = 'java.lang.RuntimeException'
            SET
              runtimeException:RuntimeException
            RETURN
              runtimeException AS RuntimeException
        ]]></cypher>
    </concept>

    <concept id="java:Error">
        <description>Labels types deriving from java.lang.Error as "Error".</description>
        <cypher><![CDATA[
            MATCH
              (throwable)-[:EXTENDS*]->(t:Type)
            WHERE
              t.fqn = 'java.lang.Error'
            SET
              throwable:Error
            RETURN
              throwable AS Error
        ]]></cypher>
    </concept>

    <concept id="java:Throwable">
        <description>Labels types deriving from java.lang.Throwable as "Throwable".</description>
        <cypher><![CDATA[
            MATCH
              (throwable)-[:EXTENDS*]->(t:Type)
            WHERE
              t.fqn = 'java.lang.Throwable'
            SET
              throwable:Throwable
            RETURN
              throwable AS Throwable
        ]]></cypher>
    </concept>

    <concept id="java:JavaVersion">
        <description>Set a human readable property "javaVersion" on a class file based on its byte code version.</description>
        <cypher><![CDATA[
            MATCH
              (:Artifact)-[:CONTAINS]->(type:Java:Type)
            SET
              type.javaVersion=
              CASE type.byteCodeVersion
                WHEN 57 THEN "Java 13"
                WHEN 56 THEN "Java 12"
                WHEN 55 THEN "Java 11"
                WHEN 54 THEN "Java 10"
                WHEN 53 THEN "Java 9"
                WHEN 52 THEN "Java 8"
                WHEN 51 THEN "Java 7"
                WHEN 50 THEN "Java 6"
                WHEN 49 THEN "Java 5"
                WHEN 48 THEN "Java 1.4"
                WHEN 47 THEN "Java 1.3"
                WHEN 46 THEN "Java 1.2"
                WHEN 45 THEN "Java 1.1/1.0"
              END
            RETURN
              count(type) as Types
        ]]></cypher>
        <verify>
            <aggregation column="Types" />
        </verify>
    </concept>

</jqa:jqassistant-rules>
