<jqassistant-rules xmlns="http://schema.jqassistant.org/rule/v2.0"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://schema.jqassistant.org/rule/v1.10 http://schema.jqassistant.org/rule/jqassistant-rule-v2.0.xsd">

    <concept id="java:InnerType">
        <description>Sets a label "Inner" on inner types.</description>
        <cypher><![CDATA[
            MATCH
              (:Java:Type)-[:DECLARES]->(innerType:Java:Type)
            SET
              innerType:Inner
            RETURN
              innerType AS InnerType
        ]]></cypher>
    </concept>

    <concept id="java:AnonymousInnerType">
        <requiresConcept refId="java:InnerType"/>
        <description>Sets a label "Anonymous" on anonymous inner types, i.e. types without a name.</description>
        <cypher><![CDATA[
            MATCH
              (innerType:Inner:Java:Type)
            WHERE
              innerType.name =~ ".*\\$[0-9]*"
            SET
              innerType:Anonymous
            RETURN
              innerType AS AnonymousInnerType
        ]]></cypher>
    </concept>

    <concept id="java:TypeAssignableFrom">
        <description>Creates a relationship ASSIGNABLE_FROM between two "Type" labeled nodes if one type is assignable
            from the other (i.e. a super class or interface).
        </description>
        <cypher transactional="false"><![CDATA[
            MATCH
              (type:Java:Type)-[:IMPLEMENTS|EXTENDS*0..]->(superType:Java:Type)
            CALL {
                WITH
                  type, superType
                MERGE
                  (superType)-[:ASSIGNABLE_FROM]->(type)
            } IN TRANSACTIONS
            RETURN
              type.fqn AS AssignableType
        ]]></cypher>
    </concept>

    <concept id="java:MemberInheritedFrom">
        <description>Creates a relationship INHERITS between two "Member" labeled nodes if a member is inherited from a
            super type.
        </description>
        <cypher transactional="false"><![CDATA[
            MATCH
              (type:Java:Type)-[:DECLARES]->(member:Member),
              (superType:Java:Type)-[:DECLARES]->(superMember:Member),
              path=shortestPath((type)-[:EXTENDS|IMPLEMENTS*]->(superType))
            WHERE
              type <> superType
              and not exists(member.name)
              and exists(superMember.name)
              and member.signature = superMember.signature
              and superMember.visibility <> "private"
            WITH
              type, member, superType, superMember, length(path) as depth
            ORDER BY
              depth asc
            WITH
              member, head(collect(superMember)) as inheritedMember
            CALL {
              WITH
                member, inheritedMember
              MERGE
                (member)-[:INHERITED_FROM]->(inheritedMember)
            } IN TRANSACTIONS
            RETURN
              count(*) as InheritedMembers
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="java:MethodOverrides">
        <requiresConcept refId="java:MemberInheritedFrom"/>
        <description>Creates a relationship OVERRIDES between two "Method" labeled nodes if a method overrides another
            one from a super type.
        </description>
        <cypher transactional="false"><![CDATA[
            MATCH
              (type:Java:Type)-[:DECLARES]->(method:Method),
              (superType:Java:Type)-[:DECLARES]->(superMethod:Method),
              path=(type)-[:EXTENDS|IMPLEMENTS*]->(superType)
            WHERE
              method.signature = superMethod.signature
              and superMethod.visibility <> "private"
              and not (
                (method)-[:INHERITED_FROM]->(:Method)
                or (superMethod)-[:INHERITED_FROM]->(:Method)
              )
            WITH
              type, method, superType, superMethod, length(path) as depth
            ORDER BY
              depth asc
            WITH
              method, head(collect(superMethod)) as overriddenMethod
            CALL {
              WITH
                method, overriddenMethod
              MERGE
                (method)-[:OVERRIDES]->(overriddenMethod)
            } IN TRANSACTIONS
            RETURN
              count(*) as OverriddenMethods
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="java:VirtualInvokes">
        <requiresConcept refId="java:MethodOverrides"/>
        <requiresConcept refId="java:MemberInheritedFrom"/>
        <description>Propagates INVOKES relationships as VIRTUAL_INVOKES to non-abstract methods within the inheritance
            hierarchy, i.e. identifying potential methods that could be invoked.
        </description>
        <cypher transactional="false"><![CDATA[
            MATCH
              (method:Method)-[invokes:INVOKES]->(:Method)-[:INHERITED_FROM*0..1]->(invokedMethod:Method),
              (invokedMethod)<-[:OVERRIDES*0..]-(overridingMethod:Method)
            WHERE NOT (                                     // exclude...
              exists(overridingMethod.abstract)             // ...abstract methods
              or (overridingMethod)-[:INHERITED_FROM]->()   // ...inherited methods
            )
            WITH
              method, overridingMethod, coalesce(invokes.lineNumber, -1) as lineNumber
            CALL {
              WITH
                method, overridingMethod, lineNumber
              MERGE
                (method)-[virtualInvokes:VIRTUAL_INVOKES{lineNumber:lineNumber}]->(overridingMethod)
            } IN TRANSACTIONS
            RETURN
              count(*) as VirtualInvokes
            ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="java:VirtualDependsOn">
        <description>Propagates DEPENDS_ON relationships as VIRTUAL_DEPENDS_ON to types that extend or implement the
            referenced type.
        </description>
        <cypher transactional="false"><![CDATA[
            MATCH
              (type:Java:Type)-[:EXTENDS|IMPLEMENTS*]->(superType:Java:Type),
              (dependent:Java:Type)-[:DEPENDS_ON]->(superType)
            WHERE NOT (
              superType.fqn = "java.lang.Object"
              or (dependent)-[:EXTENDS|IMPLEMENTS*]->(superType) // exclude types sharing the same super classes/interfaces
            )
            WITH
              dependent, collect(distinct type) as types
            UNWIND
              types as type
            CALL {
              WITH
                dependent, type
              MERGE
                (dependent)-[virtualDependsOn:VIRTUAL_DEPENDS_ON]->(type)
            } IN TRANSACTIONS
            RETURN
              count(*) AS VirtualDependsOn
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="java:MethodOverloads">
        <description>Creates a relationship OVERLOADS between two "Method" labeled nodes if one method overloads another
            one from the same type (i.e. the
            methods have the same name but not the same signature).
        </description>
        <cypher transactional="false"><![CDATA[
            MATCH
              (type:Java:Type)-[:DECLARES]->(method:Method),
              (type)-[:DECLARES]->(otherMethod:Method)
            WHERE
              method <> otherMethod
              AND method.name = otherMethod.name
              AND method.signature <> otherMethod.signature
            CALL {
              WITH method, otherMethod
              MERGE
                (method)-[:OVERLOADS]->(otherMethod)
            } IN TRANSACTIONS
            RETURN method AS OverloadedMethod, type AS DeclaringType
        ]]></cypher>
    </concept>

    <concept id="java:Deprecated">
        <description>Labels all nodes representing deprecated elements (types, fields, methods, packages or parameters)
            with "Deprecated".
        </description>
        <cypher><![CDATA[
            MATCH
              (e)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(dt:Java:Type)
            WHERE
              dt.fqn='java.lang.Deprecated'
            SET
              e:Deprecated
            RETURN
              e AS DeprecatedElement
        ]]></cypher>
    </concept>

    <concept id="java:Exception">
        <description>Labels types deriving from java.lang.Exception as "Exception".</description>
        <cypher><![CDATA[
            MATCH
              (exception)-[:EXTENDS*]->(t:Java:Type)
            WHERE
              t.fqn = 'java.lang.Exception'
            SET
              exception:Exception
            RETURN
              exception AS Exception
        ]]></cypher>
    </concept>

    <concept id="java:RuntimeException">
        <description>Labels types deriving from java.lang.RuntimeException as "RuntimeException".</description>
        <cypher><![CDATA[
            MATCH
              (runtimeException)-[:EXTENDS*]->(t:Java:Type)
            WHERE
              t.fqn = 'java.lang.RuntimeException'
            SET
              runtimeException:RuntimeException
            RETURN
              runtimeException AS RuntimeException
        ]]></cypher>
    </concept>

    <concept id="java:Error">
        <description>Labels types deriving from java.lang.Error as "Error".</description>
        <cypher><![CDATA[
            MATCH
              (throwable)-[:EXTENDS*]->(t:Java:Type)
            WHERE
              t.fqn = 'java.lang.Error'
            SET
              throwable:Error
            RETURN
              throwable AS Error
        ]]></cypher>
    </concept>

    <concept id="java:Throwable">
        <description>Labels types deriving from java.lang.Throwable as "Throwable".</description>
        <cypher><![CDATA[
            MATCH
              (throwable)-[:EXTENDS*]->(t:Java:Type)
            WHERE
              t.fqn = 'java.lang.Throwable'
            SET
              throwable:Throwable
            RETURN
              throwable AS Throwable
        ]]></cypher>
    </concept>

    <concept id="java:JavaVersion">
        <description>Set a human readable property "javaVersion" on a class file based on its byte code version.
        </description>
        <cypher><![CDATA[
            MATCH
              (:Artifact)-[:CONTAINS]->(type:Java:Type)
            SET
              type.javaVersion=
              CASE type.byteCodeVersion
                WHEN 58 THEN "Java 14"
                WHEN 57 THEN "Java 13"
                WHEN 56 THEN "Java 12"
                WHEN 55 THEN "Java 11"
                WHEN 54 THEN "Java 10"
                WHEN 53 THEN "Java 9"
                WHEN 52 THEN "Java 8"
                WHEN 51 THEN "Java 7"
                WHEN 50 THEN "Java 6"
                WHEN 49 THEN "Java 5"
                WHEN 48 THEN "Java 1.4"
                WHEN 47 THEN "Java 1.3"
                WHEN 46 THEN "Java 1.2"
                WHEN 45 THEN "Java 1.1/1.0"
              END
            RETURN
              count(type) as Types
        ]]></cypher>
        <verify>
            <aggregation column="Types"/>
        </verify>
    </concept>

    <concept id="java:FunctionalInterface">
        <description>Labels functional interfaces (i.e. to be used as lambda expressions)
            with `FunctionalInterface`.
        </description>
        <cypher transactional="false"><![CDATA[
            MATCH
                (i:Java:Interface)-[:DECLARES]->(m:Member:Java:Method {abstract: true})
            WITH
                i, count(m) AS methods
            WHERE
                methods = 1
            CALL {
              WITH
                i
              SET
                i:FunctionalInterface
            } IN TRANSACTIONS
            RETURN
                i AS FunctionInterface
        ]]></cypher>
    </concept>

    <concept id="java:DefaultMethod">
        <description>Labels default methods of interfaces with `Default`.</description>
        <cypher><![CDATA[
            MATCH
              (type:Type:Java:Interface)-[:DECLARES]->(defaultMethod:Java:Method)
            WHERE NOT
              exists(defaultMethod.abstract)
            SET
              defaultMethod:Default
            RETURN
              defaultMethod AS DefaultMethod, type AS Interface
        ]]></cypher>
    </concept>

    <concept id="java:PostConstruct">
        <description>Labels methods annotated `@javax.annotation.PostConstruct` with 'PostConstruct'.
        </description>
        <cypher><![CDATA[
            MATCH
              (postConstruct:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(:Java:Type{fqn:"javax.annotation.PostConstruct"})
            SET
              postConstruct:PostConstruct
            RETURN
              postConstruct as PostConstruct
        ]]></cypher>
    </concept>

    <concept id="java:PreDestroy">
        <description>Labels methods annotated `@javax.annotation.PreDestroy` with 'PreDestroy'.
        </description>
        <cypher><![CDATA[
            MATCH
              (preDestroy:Method)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(:Java:Type{fqn:"javax.annotation.PreDestroy"})
            SET
              preDestroy:PreDestroy
            RETURN
              preDestroy as PreDestroy
        ]]></cypher>
    </concept>

    <concept id="java:PackageAnnotatedBy">
        <description>Propagates the annotations from the package-info.java to the package node.</description>
        <cypher><![CDATA[
            MATCH
              (p:Package)-[:CONTAINS]->(t:Java:Type{sourceFileName: "package-info.java"}),
              (t)-[:ANNOTATED_BY]->(a:Annotation)
            MERGE
              (p)-[:ANNOTATED_BY]->(a)
            RETURN p
        ]]></cypher>
    </concept>


    <concept id="java:GeneratedType" severity="minor">
        <description>Reports the count of types labeled with `Generated`, grouped by containing artifact.</description>
        <cypher><![CDATA[
            MATCH
              (artifact:Artifact)-[:CONTAINS]->(generatedType:Java:Type:Generated)
            RETURN
              artifact as Artifact, count(generatedType) as GeneratedTypes
            ORDER BY
              GeneratedTypes desc
        ]]></cypher>
        <verify>
            <aggregation column="GeneratedTypes"/>
        </verify>
    </concept>

    <concept id="java:InnerTypeParameterDeclaredByOuterType">
        <description>Creates a `DECLARED_BY` relation of a type parameter required by an inner to type to its
            declaration by an outer type.
        </description>
        <cypher><![CDATA[
            MATCH
              (inner:Java:Type)-[requires:REQUIRES_TYPE_PARAMETER]->(requiredTypeParameter:TypeVariable),
              (outer:Java:Type)-[declares:DECLARES_TYPE_PARAMETER]->(declaredTypeParameter:TypeVariable),
              shortestPath((outer)-[:DECLARES*]->(inner))
            WHERE
              outer <> inner
              and declaredTypeParameter.name = requiredTypeParameter.name
            MERGE
              (requiredTypeParameter)-[declaredBy:DECLARED_BY]->(declaredTypeParameter)
            RETURN
              count(declaredBy) as OuterTypeDeclarations
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

    <concept id="java:TypeArgumentDeclaredByTypeParameter">
        <description>Creates a `DECLARED_BY` relation between a type argument of a parameterized type to the according type parameter of the declaring type.
        </description>
        <cypher><![CDATA[
            MATCH
              (parameterizedType:ParameterizedType)-[:OF_RAW_TYPE]->(rawType:Java:Type),
              (parameterizedType)-[hasActualTypeArgument:HAS_ACTUAL_TYPE_ARGUMENT]->(typeArgument),
              (rawType)-[declaresTypeParameter:DECLARES_TYPE_PARAMETER]->(typeParameter)
            WHERE
              hasActualTypeArgument.index = declaresTypeParameter.index
            MERGE
              (typeArgument)-[:DECLARED_BY]->(typeParameter)
            RETURN
              count(*) as TypeParameterDeclarations
        ]]></cypher>
        <verify>
            <aggregation/>
        </verify>
    </concept>

</jqassistant-rules>

