<jqa:jqassistant-rules xmlns:jqa="http://www.buschmais.com/jqassistant/core/analysis/rules/schema/v1.0">

    <concept id="dependency:Annotation">
        <description>Creates a DEPENDS_ON relationship between an annotated element and the types of the annotation and
            its values.
        </description>
        <cypher><![CDATA[
            MATCH
                (e)-[:ANNOTATED_BY]->(a:Annotation)-[:OF_TYPE]->(at:Type)
            WHERE
                e:Type
                or e:Method
                or e:Parameter
                or e:Field
            CREATE UNIQUE
                (e)-[:DEPENDS_ON]->(at)
            WITH
                e, a
            MATCH
                (a)-[:HAS|IS|CONTAINS|OF_TYPE*0..]->(vt:Type)
            CREATE UNIQUE
                (e)-[:DEPENDS_ON]->(vt)
            RETURN
                e AS AnnotatedType, COUNT(DISTINCT vt) as Elements
        ]]></cypher>
    </concept>

    <concept id="dependency:MethodParameter">
        <requiresConcept refId="dependency:Annotation"/>
        <description>Creates a DEPENDS_ON relationship between a method and the types of its parameters.</description>
        <cypher><![CDATA[
            MATCH
                (m:Method)-[:HAS]->(p:Parameter)-[:OF_TYPE|DEPENDS_ON]->(t:Type)
            CREATE UNIQUE
                (m)-[:DEPENDS_ON]->(t)
            RETURN
                m AS Method, COUNT(DISTINCT t) as Parameters
        ]]></cypher>
    </concept>

    <concept id="dependency:MethodInvocation">
        <requiresConcept refId="dependency:MethodParameter"/>
        <description>Creates a DEPENDS_ON relationship between a method and the dependencies of the method signature it
            invokes.
        </description>
        <cypher><![CDATA[
            MATCH
                (m:Method)-[:INVOKES]->(target:Method),
                (dt:Type)-[:DECLARES]->(target)
            CREATE UNIQUE
                (m)-[:DEPENDS_ON]->(dt)
            WITH
                m, target
            MATCH
                (target)-[:HAS]->(:Parameter)-[:DEPENDS_ON]->(pt)
            CREATE UNIQUE
                (m)-[:DEPENDS_ON]->(pt)
            WITH
                m, target
            MATCH
                (target)-[:RETURNS]->(rt)
            CREATE UNIQUE
                (m)-[:DEPENDS_ON]->(rt)
            RETURN
                m AS Method, COUNT(DISTINCT rt) AS MethodInvocations
        ]]></cypher>
    </concept>

    <concept id="dependency:FieldAccess">
        <description>Creates a DEPENDS_ON relationship between a method and all fields types it reads and writes.
        </description>
        <cypher><![CDATA[
            MATCH
                (m:Method)-[:READS|WRITES]->(target:Field),
                (dt:Type)-[:DECLARES]->(target)
            CREATE UNIQUE
                (m)-[:DEPENDS_ON]->(dt)
            WITH
                m, target
            MATCH
                  (target)-[:OF_TYPE|DEPENDS_ON]->(ft)
            CREATE UNIQUE
                (m)-[:DEPENDS_ON]->(ft)
            RETURN
                m AS method, COUNT(DISTINCT ft) AS FieldAccesseCount
        ]]></cypher>
    </concept>

    <concept id="dependency:TypeBody">
        <requiresConcept refId="dependency:Annotation"/>
        <requiresConcept refId="dependency:MethodParameter"/>
        <requiresConcept refId="dependency:MethodInvocation"/>
        <requiresConcept refId="dependency:FieldAccess"/>
        <description>Creates a DEPENDS_ON relationship between a type and all types its body (i.e. methods and fields)
            depends on.
        </description>
        <cypher><![CDATA[
            MATCH
                (t1:Type)-[:DECLARES*0..1]->(fieldOrMethod)-[:OF_TYPE|RETURNS|DEPENDS_ON|THROWS]->(t2:Type)
            WHERE
                t1<>t2
                and (fieldOrMethod:Field OR fieldOrMethod:Method)
            CREATE UNIQUE
                (t1)-[:DEPENDS_ON]->(t2)
            RETURN
                t1 AS Type, COUNT(DISTINCT t2) AS DependencyCount
        ]]></cypher>
    </concept>

    <concept id="dependency:Type">
        <requiresConcept refId="dependency:TypeBody"/>
        <description>Creates a DEPENDS_ON relationship between a type and all types its signature and body depends on.
        </description>
        <cypher><![CDATA[
            MATCH
                (t1:Type)-[:EXTENDS|IMPLEMENTS]->(t2:Type)
            WHERE
                t1<>t2
            CREATE UNIQUE
                (t1)-[:DEPENDS_ON]->(t2)
            RETURN
                t1 AS Type, COUNT(DISTINCT t2) AS DependencyCount
        ]]></cypher>
    </concept>

    <concept id="dependency:Package">
        <requiresConcept refId="dependency:Type"/>
        <description>Creates a DEPENDS_ON relationship between a packages if there are type dependencies between them.
        </description>
        <cypher><![CDATA[
            MATCH
                (p1:Package)-[:CONTAINS]->(t1:Type)-[:DEPENDS_ON]->(t2:Type)<-[:CONTAINS]-(p2:Package)
            WHERE
                p1<>p2
            CREATE UNIQUE
                (p1)-[:DEPENDS_ON]->(p2)
            RETURN
                p1 AS package, COUNT(DISTINCT p2) AS PackageDependencyCount
        ]]></cypher>
    </concept>

    <concept id="dependency:Artifact">
        <requiresConcept refId="dependency:Type"/>
        <description>Creates a DEPENDS_ON relationship between artifacts if there are type dependencies between them.
        </description>
        <cypher><![CDATA[
            MATCH
                (a1:Artifact)-[:CONTAINS]->(t1:Type)-[:DEPENDS_ON]->(t2:Type)<-[:CONTAINS]-(a2:Artifact)
            WHERE
                a1<>a2
            CREATE UNIQUE
                (a1)-[:DEPENDS_ON]->(a2)
            RETURN
                a1 AS Artifact, COLLECT(DISTINCT a2.name) AS Dependencies
        ]]></cypher>
    </concept>

    <constraint id="dependency:PackageCycles">
        <requiresConcept refId="dependency:Package"/>
        <description>There must be no cyclic package dependencies.</description>
        <cypher><![CDATA[
            MATCH
                (p1:Package)-[:DEPENDS_ON]->(p2:Package),
                path=shortestPath((p2)-[:DEPENDS_ON*]->(p1))
            WHERE
                p1<>p2
            RETURN
                p1 AS Package, EXTRACT(p IN nodes(path) | p.fqn) AS Cycle
            ORDER BY
                Package.fqn
        ]]></cypher>
    </constraint>

    <constraint id="dependency:TypeCycles">
        <requiresConcept refId="dependency:Package"/>
        <description>There must be no cyclic type dependencies.</description>
        <cypher><![CDATA[
            MATCH
                (p1:Package)-[:DEPENDS_ON*0..1]->(p2:Package),
                shortestPath((p2)-[:DEPENDS_ON*]->(p1))
            WITH
                p1, p2
            MATCH
                (p1)-[:CONTAINS]->(t1:Type),
                (p2)-[:CONTAINS]->(t2:Type),
                (t1)-[:DEPENDS_ON]->(t2),
                path=shortestPath((t2)-[:DEPENDS_ON*]->(t1))
            WHERE
                NOT (
                  t1 = t2 OR (t1)-[:DECLARES]-(t2)
                )
            RETURN
                LENGTH(path) AS Length, EXTRACT(p IN nodes (path) | p.fqn) AS Cycle
        ]]></cypher>
    </constraint>

    <constraint id="dependency:ArtifactCycles">
        <requiresConcept refId="dependency:Artifact"/>
        <description>There must be no cyclic artifact dependencies.</description>
        <cypher><![CDATA[
            MATCH
                (a1:Artifact)-[:DEPENDS_ON]->(a2:Artifact),
                path=shortestPath((a2)-[:DEPENDS_ON*]->(a1))
            WHERE
                a1<>a2
            RETURN
                a1 AS Artifact, EXTRACT(a IN nodes(path) | a.fqn) AS Cycle
            ORDER BY
                Artifact.fqn
        ]]></cypher>
    </constraint>

</jqa:jqassistant-rules>
